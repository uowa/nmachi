#!/usr/bin/env node

/**
 * ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®èª­ã¿è¾¼ã¿
 */
const app = require('../app');                     // Expressã‚¢ãƒ—ãƒªæœ¬ä½“
const debug = require('debug')('pmachi6:server'); // ãƒ‡ãƒãƒƒã‚°ç”¨
const fs = require('fs');                          // ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œç”¨
const http = require('http');                      // HTTPã‚µãƒ¼ãƒãƒ¼ç”¨
const https = require('https');                    // HTTPSã‚µãƒ¼ãƒãƒ¼ç”¨

/**
 * ãƒãƒ¼ãƒˆç•ªå·ã‚’æ­£è¦åŒ–ã™ã‚‹é–¢æ•°
 * - æ•°å­—ãªã‚‰ãã®ã¾ã¾è¿”ã™
 * - named pipe ãªã‚‰æ–‡å­—åˆ—ã‚’è¿”ã™
 * - ç„¡åŠ¹ãªã‚‰ false ã‚’è¿”ã™
 */
function normalizePort(val) {
  const port = parseInt(val, 10);
  if (isNaN(port)) {
    // æ•°å­—ã«å¤‰æ›ã§ããªã‘ã‚Œã° named pipe ã¨ã¿ãªã™
    return val;
  }
  if (port >= 0) {
    // æ­£ã®æ•°å­—ãªã‚‰ãƒãƒ¼ãƒˆç•ªå·ã¨ã—ã¦è¿”ã™
    return port;
  }
  return false; // ç„¡åŠ¹ãªãƒãƒ¼ãƒˆ
}



//ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼æ™‚ã®å‡¦ç†
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error; // listen ç³»ã®ã‚¨ãƒ©ãƒ¼ã§ãªã‘ã‚Œã°æŠ•ã’ã‚‹
  }

  const bind = typeof port === 'string'
    ? 'Pipe ' + port  // named pipe ã®å ´åˆ
    : 'Port ' + port; // ãƒãƒ¼ãƒˆç•ªå·ã®å ´åˆ

  // ç‰¹å®šã®ã‚¨ãƒ©ãƒ¼ã«å¯¾ã—ã¦ã‚ã‹ã‚Šã‚„ã™ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' ã¯ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' ã¯æ—¢ã«ä½¿ç”¨ä¸­ã§ã™');
      process.exit(1);
      break;
    default:
      throw error;
  }
}


// ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ãŸã¨ãã®å‡¦ç†
function onListening() {
  const addr = server.address();
  const bind = typeof addr === 'string'
    ? 'pipe ' + addr      // named pipe ã®å ´åˆ
    : 'port ' + addr.port; // ãƒãƒ¼ãƒˆç•ªå·ã®å ´åˆ
  debug('Listening on ' + bind); // ãƒ‡ãƒãƒƒã‚°ç”¨å‡ºåŠ›
}


// ç’°å¢ƒå¤‰æ•°ã‚„ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‹ã‚‰ãƒãƒ¼ãƒˆç•ªå·ã‚’å–å¾—ã—ã¦ Express ã«è¨­å®š
const port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * ã‚µãƒ¼ãƒãƒ¼ä½œæˆ
 * - SSL ã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Œã° HTTPS
 * - ãªã‘ã‚Œã° HTTP
 */
let server;

try {
  // SSL è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
  const nmachi_key = '../../../../usr/local/nginx/nmachi20201226.key';
  const nmachi_crt = '../../../../usr/local/nginx/nmachi20220126.crt';
  const nmachi_chain = '../../../../usr/local/nginx/nmachi20220126.pem';

  // SSL ã‚ªãƒ—ã‚·ãƒ§ãƒ³ä½œæˆ
  const options = {
    key: fs.readFileSync(nmachi_key),
    cert: fs.readFileSync(nmachi_crt),
    ca: fs.readFileSync(nmachi_chain)
  };

  // HTTPS ã‚µãƒ¼ãƒãƒ¼ä½œæˆ
  server = https.createServer(options, app);
  console.log('HTTPS ã‚µãƒ¼ãƒãƒ¼ã‚’ä½œæˆã—ã¾ã—ãŸ');
} catch (err) {
  // ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° HTTP ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
  console.warn('SSL ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚HTTP ã‚µãƒ¼ãƒãƒ¼ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™');
  server = http.createServer(app);
}

// Socket.IO ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— - ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡ã™ã‚‹ãŸã‚ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
const io = require('socket.io')(server);


// ç’°å¢ƒã«å¿œã˜ã¦ã‚µãƒ¼ãƒãƒ¼ã®ãƒã‚¤ãƒ³ãƒ‰å…ˆã‚’æ±ºå®š
// NODE_ENV ãŒ 'production' ã®å ´åˆ â†’ æœ¬ç•ªç’°å¢ƒã¨ã¿ãªã— localhost ã«ãƒã‚¤ãƒ³ãƒ‰
// Codespaces ä¸Šã®å ´åˆ â†’ process.env.CODESPACE ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã®ã§ 0.0.0.0 ã«ãƒã‚¤ãƒ³ãƒ‰ï¼ˆå¤–éƒ¨ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ï¼‰
// ãã‚Œä»¥å¤–ï¼ˆé€šå¸¸ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºãªã©ï¼‰ â†’ localhost ã«ãƒã‚¤ãƒ³ãƒ‰
const isCodespaces = !!process.env.CODESPACES || !!process.env.CODESPACE_NAME;
const host = process.env.NODE_ENV === 'production' ? 'localhost'
  : isCodespaces ? '0.0.0.0'
    : 'localhost';




// ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
server.listen(port, host, () => {
  console.log(`Server running at http://${host}:${port}/`);
});
server.on('error', onError);
server.on('listening', onListening);


let ip = {};

let user = {};
let socketID = {};
let tokenNum = 0;

let rooms = {};
let roomNameList = ["ã‚¨ãƒ³ãƒˆãƒ©ãƒ³ã‚¹", "ã†ã¡ã‚…ãƒ¼", "æ˜Ÿ1",];
for (let i = 0; i < roomNameList.length; i++) {
  rooms[roomNameList[i]] = {
    drawHistory: [],
    usersToken: new Set(),
  };
}

const { setInterval } = require('timers');

const crypto = require("crypto");

function tripCreate(isTrip) {
  let tripkey = isTrip;
  // ã‚½ãƒ«ãƒˆç”Ÿæˆï¼ˆ2æ–‡å­—ä»¥ä¸Šã«ãªã‚‹ã‚ˆã†ã« 'H.' ã‚’è¿½åŠ ã—ã€2æ–‡å­—ç›®ã¨3æ–‡å­—ç›®ã‚’åˆ‡ã‚Šå‡ºã—ï¼‰
  let salt = (tripkey + "H.").slice(1, 3);
  salt = salt.replace(/[^.-z]/g, ".");
  salt = salt.replace(/:/g, "A");
  salt = salt.replace(/;/g, "B");
  salt = salt.replace(/</g, "C");
  salt = salt.replace(/=/g, "D");
  salt = salt.replace(/>/g, "E");
  salt = salt.replace(/\?/g, "F");
  salt = salt.replace(/@/g, "G");
  salt = salt.replace(/\[/g, "a");
  salt = salt.replace(/\\/g, "b");
  salt = salt.replace(/]/g, "c");
  salt = salt.replace(/\^/g, "d");
  salt = salt.replace(/_/g, "e");
  salt = salt.replace(/`/g, "f");

  // AESç”¨ã®ã‚­ãƒ¼ã¨IVã‚’ç”Ÿæˆï¼ˆ16ãƒã‚¤ãƒˆãšã¤ã€saltã‚’åŸ‹ã‚ã¦æ®‹ã‚Šã¯0åŸ‹ã‚ï¼‰
  const key = Buffer.alloc(32, 0); // AES-256ãªã®ã§32ãƒã‚¤ãƒˆ
  key.write(salt, 0, "utf-8");
  const iv = Buffer.alloc(16, 0);  // IVã¯16ãƒã‚¤ãƒˆ
  iv.write(salt, 0, "utf-8");

  // æš—å·åŒ–
  const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
  let encrypted = cipher.update(tripkey, "utf-8", "base64");
  encrypted += cipher.final("base64");

  // ãƒˆãƒªãƒƒãƒ—ã¨ã—ã¦æœ«å°¾10æ–‡å­—ï¼ˆ=ã¯é™¤å»ï¼‰
  let trip = encrypted.substr(-10).replace(/=/g, "");
  trip = "â—†" + trip;
  return trip;
}

let msgSE = {};
msgSE.login = {};
msgSE.login.in = new Array(0);
msgSE.login.logout = new Array(0);
msgSE.other = {};
msgSE.other.in = new Array(1);
msgSE.other.out = new Array(3);
msgSE.other.logout = new Array(1);
msgSE.outerSpace = {};
msgSE.outerSpace.in = new Array(1);
msgSE.outerSpace.out = new Array(1);
msgSE.outerSpace.logout = new Array(1);

function time() {
  return " -- " + new Date().getHours().toLocaleString() + ":" + new Date().getMinutes().toLocaleString() + "--";
}


let random;
function volumeRandom(roomName, move) {
  if (roomName === "ã‚¨ãƒ³ãƒˆãƒ©ãƒ³ã‚¹") {//â€»éƒ¨å±‹æ•°ãŒå¢—ãˆãŸã‚‰||ã§ç¶™ãè¶³ã™
    random = Math.floor(Math.random() * msgSE.other[move].length);
  } else if (roomName === "ã†ã¡ã‚…ãƒ¼" || roomName === "æ˜Ÿ1") {
    random = Math.floor(Math.random() * msgSE.outerSpace[move].length);
  } else {
    random = Math.floor(Math.random() * msgSE[roomName][move].length);
  }
  return random;
}

//æ˜Ÿ1ã®æ˜Ÿã®è‰²ç”¨ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒ©ãƒ¼é…åˆ—ä½œæˆ
const starColors = [];
setStarRandomColor();

function setStarRandomColor() {
  starColors.length = 0;
  for (let i = 0; i < 1000; i++) {
    // 0x000000ï½0xFFFFFFã®ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒ©ãƒ¼
    starColors.push(Math.floor(Math.random() * 0xFFFFFF));
  }
}


// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ãŸã¨ãã®å‡¦ç†
io.on('connection', socket => {
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã«ä¸€æ„ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç™ºè¡Œ
  const token = crypto.randomUUID();
  socketID[token] = socket.id;

  // ã‚µãƒ¼ãƒãƒ¼å†èµ·å‹•æ™‚ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸å†èª­ã¿è¾¼ã¿ã‚’ä¿ƒã™ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹é–¢æ•°
  function checkUser() {
    if (!user[token]) {
      io.to(socket.id).emit("emitSaikiMsg", {
        msg: "ãƒ–ãƒ©ã‚¦ã‚¶ã‚’æ›´æ–°ã—ã¦ãã ã•ã„",
      });
      return false;
    }
    return true;
  }

  /**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¯ã¦ãŸã‚‰èµ·ã“ã™é–¢æ•°ã€‚
 * sleepTimeNumãŒ30åˆ†ä»¥ä¸Šã‹ã¤selfSleepãŒfalseã®å ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®sleepçŠ¶æ…‹ã‚’falseã«è¨­å®šã—ã€
 * å¯¾å¿œã™ã‚‹ãƒ«ãƒ¼ãƒ ã«sleepã‚¤ãƒ™ãƒ³ãƒˆã‚’é€ä¿¡ã—ã¾ã™ã€‚ãã®å¾Œã€sleepTimeNumã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚
 */
  function sleepTime() {
    if (user[token].sleepTimeNum >= 30 * 60 && user[token].selfSleep == false) {
      user[token].sleep = false;
      io.to(user[token].room).emit("sleep", {
        token: token,
        sleep: user[token].sleep,
      });
    }
    user[token].sleepTimeNum = 0;
  }



  // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆ
  socket.on("getMyUser", () => {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’åˆæœŸåŒ–ã—ã¦ä¿å­˜
    user[token] = {
      userName: "åã‚‚ãªãåç„¡ã—", // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå
      token: token,
      AX: 457, // åˆæœŸXåº§æ¨™
      AY: 80,  // åˆæœŸYåº§æ¨™
      DIR: "S", // åˆæœŸå‘ã
      msg: "",
      tarAspect: "gomaneco", // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒã‚¿ãƒ¼
      room: "loginRoom",   // åˆæœŸéƒ¨å±‹
      video: false,
      audio: false,
      timeShade: new Date().getHours(),
      avatarAlpha: 1.0,//ã‚¢ãƒã‚¿ãƒ¼ã®é€æ˜åº¦
      sleep: false,
      sit: false,
      selfSleep: false,//ãƒ¦ãƒ¼ã‚¶ãƒ¼è‡ªèº«ã§è¨­å®šã—ãŸçœ ã‚ŠçŠ¶æ…‹
      sleepTimeNum: 0,
      drawHistory: [],
      carryOver: false,//ãƒ­ã‚°æ®‹ã—çŠ¶æ…‹ã‹ã©ã†ã‹

      // ä¸€å®šæ™‚é–“æ“ä½œãŒãªã‘ã‚Œã°è‡ªå‹•ã§ã‚¹ãƒªãƒ¼ãƒ—çŠ¶æ…‹ã«ã™ã‚‹é–¢æ•°
      countSleep: () => {
        let setTimeoutSleep;
        if (user[token]) {
          user[token].sleepTimeNum++;
          // 30åˆ†ï¼ˆ1800ç§’ï¼‰çµŒéã§ã‚¹ãƒªãƒ¼ãƒ—
          if (user[token].sleepTimeNum == 30 * 60) {
            user[token].sleep = true;
            io.to(user[token].room).emit("sleep", {
              token: token,
              sleep: user[token].sleep,
            });
          }
          setTimeoutSleep = setTimeout(user[token].countSleep, 1000); // 1ç§’ã”ã¨ã«ã‚«ã‚¦ãƒ³ãƒˆ
        } else {
          clearTimeout(setTimeoutSleep); // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ãªã‘ã‚Œã°ã‚¿ã‚¤ãƒãƒ¼è§£é™¤
        }
      },
    }

    tokenNum++;

    io.to(socket.id).emit("userInit", {
      token: token,
    });
    user[token].countSleep();
  });


  socket.on("joineRoom", data => {//éƒ¨å±‹ç§»å‹•
    if (!checkUser()) return;
    // IPå–å¾—æ–¹æ³•ã®æ¤œè¨¼ç”¨
    // console.log("userIP");
    // console.log(socket.handshake.address);
    // console.log(socket.handshake.address.address);
    // console.log(socket.handshake.address.port);
    // console.log(socket.handshake.headers['x-forwarded-for']);
    // console.log(socket.request.headers['x-forwarded-for']);
    // console.log(socket.request.connection.remoteAddress);
    let announce;
    let fromRoom = user[token].room;
    user[token].room = data.toRoom;
    rooms[data.toRoom].usersToken.add(token);//éƒ¨å±‹ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆã«è¿½åŠ 
    user[token].carryOver = false;


    if (fromRoom === "loginRoom" && data.userName.length < 28) {//ãƒ­ã‚°ã‚¤ãƒ³ã®æ™‚ã‹ã¤ã€åå‰ãŒ28æœªæº€ã®æ™‚
      //ãƒˆãƒªãƒƒãƒ—ã‚’ä½œã‚‹
      if (!ip[socket.handshake.address]) {
        ip[socket.handshake.address] = { name: [data.userName], ip: socket.handshake.address };
      } else {
        if (!ip[socket.handshake.address].name.includes(data.userName)) {
          ip[socket.handshake.address].name.push(data.userName);
        }
      }
      data.userName = data.userName.replace(/â—†/g, 'â–¡');
      if (data.userName.match(/#/)) {
        let index = data.userName.indexOf("#");
        let tripStr = data.userName.slice(index + 1);
        let tripName = data.userName.slice(0, index);
        data.userName = tripName + tripCreate(tripStr);
      }
      if (data.userName.match(/ï¼ƒ/)) {
        let index = data.userName.indexOf("ï¼ƒ");
        let tripStr = data.userName.slice(index + 1);
        let tripName = data.userName.slice(0, index);
        data.userName = tripName + tripCreate(tripStr);
      }
      user[token].userName = data.userName;//åå‰ã‚’ã‚µãƒã«ä¿å­˜
      user[token].avatarAspect = data.avatarAspect;//ã‚¢ãƒã‚¿ãƒ¼ã‚’è¨­å®š
      user[token].avatarColor = data.avatarColor;//ã‚¢ãƒã‚¿ãƒ¼ã®è‰²ã‚’è¨­å®š
      user[token].avatarAlpha = data.avatarAlpha;//ã‚¢ãƒã‚¿ãƒ¼ã®é€æ˜åº¦ã‚’è¨­å®š

      //soundNumã®æ±ºå®š
      user[token].soundNum = data.userName.length;
      if (data.avatar == "necosuke" || data.avatar == "necosukeMono") {
        user[token].soundNum++;
      }
      user[token].soundNum += data.avatarColor;
      user[token].soundNum = user[token].soundNum % 9;

      random = volumeRandom("login", "in");

      //ã‚¢ãƒã‚¿ãƒ¼ãŠçµµæã
      user[token].drawHistory = data.drawHistory;

      announce = user[token].userName + "ãŒ" + data.toRoom + "ã«å…¥å®¤ã—ã¾ã—ãŸã€‚" + time();
    } else {//loginRoomã‹ã‚‰ä»¥å¤–ã®æ™‚
      //é€€å®¤å‡¦ç†
      rooms[fromRoom].usersToken.delete(token);//å…ƒã®éƒ¨å±‹ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤

      if (data.train) {
        announce = user[token].userName + "ãŒé›»è»Šã«ä¹—ã‚Šè¾¼ã¿ã¾ã—ãŸã€ã‚†ã‚“ã‚„ãƒ¼ï¼" + time();
      } else {
        announce = user[token].userName + "ãŒ" + data.toRoom + "ã«ç§»å‹•ã—ã¾ã—ãŸã€‚" + time();
      }

      if (fromRoom === "æ˜Ÿ1") {
        setStarRandomColor();
      }

      socket.broadcast.to(fromRoom).emit("otherLeft", {//è‡ªåˆ†ä»¥å¤–ãŒéƒ¨å±‹ã‚’å‡ºãŸå ´åˆ
        token: token,
        random: volumeRandom(fromRoom, "out"),
        announce: announce,
        starColors: starColors,
      });



      //å…¥å®¤å‡¦ç†
      switch (data.toSpot) {
        case "entranceCloud1":
          user[token].AX = 150;
          user[token].AY = 130;
          user[token].DIR = "S";
          break;
        case "outerSpaceMainSpot":
          user[token].AX = 200;
          user[token].AY = 300;
          user[token].DIR = "S";
          break;
        case "star1EntrySpot":
          user[token].AX = 334;
          user[token].AY = 450;
          user[token].DIR = "N";
          break;
      }
      user[token].msg = "";

      if (data.train) {
        announce = user[token].userName + "ãŒé›»è»Šã«ä¹—ã£ã¦ãã¾ã—ãŸã€‚" + time();
      } else {
        announce = user[token].userName + "ãŒ" + fromRoom + "ã‹ã‚‰ç§»å‹•ã—ã¦ãã¾ã—ãŸã€‚" + time();
      }
      random = volumeRandom(data.toRoom, "in");
    }


    if (fromRoom !== data.toRoom) {
      socket.leave(fromRoom);
      socket.join(data.toRoom);
    }

    io.to(socket.id).emit("joineRoom", {
      user: user,
      announce: announce,
      fromRoom: fromRoom,
      toRoom: data.toRoom,
      drawHistory: rooms[data.toRoom].drawHistory,
      random: random,
      starColors: starColors,
    });

    socket.broadcast.to(data.toRoom).emit("otherJoined", {
      userName: user[token].userName,
      token: token,
      avatarAspect: user[token].avatarAspect,
      avatarColor: user[token].avatarColor,
      avatarAlpha: user[token].avatarAlpha,
      AX: user[token].AX,
      AY: user[token].AY,
      DIR: user[token].DIR,
      sit: user[token].sit,
      sleep: user[token].sleep,
      announce: announce,
      msg: user[token].msg,
      drawHistory: user[token].drawHistory,

      fromRoom: fromRoom,
      toRoom: data.toRoom,
      random: random
    });
    sleepTime();
  });





  //sleepæƒ…å ±ã‚’å—ã‘å–ã£ãŸã‚‰è‡ªåˆ†ä»¥å¤–ã®éƒ¨å±‹ã®äººã«ã‚¹ãƒªãƒ¼ãƒ—æƒ…å ±ã‚’é€ã‚‹
  socket.on("sleep", () => {
    if (!checkUser()) return;
    if (user[token].sleep) {//å¯ã¦ãŸæ™‚
      user[token].sleep = false;
      user[token].selfSleep = false;
      user[token].DIR = "S";
    } else {//èµ·ãã¦ãŸæ™‚
      user[token].sleep = true;
      user[token].selfSleep = true;
    }
    socket.broadcast.to(user[token].room).emit("sleep", {
      token: token,
      sleep: user[token].sleep,
    });
    user[token].sleepTimeNum = 0;
  });

  //ã‚¢ãƒœãƒ³ã‚’å—ã‘å–ã£ãŸã‚‰ã€ã‚¢ãƒœãƒ³è¨­å®šã‚’è¡Œã†
  socket.on("abonSetting", data => {
    if (!checkUser()) return;
    let abonMsg;
    if (user[data.token] == null) {
      abonMsg = "ãã®ä½æ°‘ã¯é€€å‡ºæ¸ˆã¿ã§ã™";
      io.to(socket.id).emit("abonSetting", {
        msg: abonMsg,
      });
    } else if (!data.setAbon) {
      abonMsg = user[data.token].userName + "ã‚’ã‚¢ãƒœãƒ³ã—ã¾ã—ãŸã€‚";
      io.to(socket.id).emit("abonSetting", {
        msg: abonMsg,
        token: data.token,
      });
    } else {
      abonMsg = user[data.token].userName + "ã®ã‚ã¼ã‚“ã‚’ã‚„ã‚ã¾ã—ãŸ";
      io.to(socket.id).emit("abonSetting", {
        msg: abonMsg,
        token: data.token,
        AX: user[data.token].AX,
        AY: user[data.token].AY,
        DIR: user[data.token].DIR,
        sit: user[data.token].sit,
        room: user[data.token].room,
        alpha: user[data.token].avatarAlpha,
        sleep: user[data.token].sleep,
      });
    }
    sleepTime();
  });


  //tapã‚¤ãƒ™ãƒ³ãƒˆ
  socket.on('tapMap', data => {
    if (!checkUser()) return;
    user[token].DIR = data.DIR;
    user[token].AX = data.AX;
    user[token].AY = data.AY;
    user[token].sit = data.sit;

    socket.broadcast.to(user[token].room).emit("tapMap", {
      DIR: data.DIR,
      token: token,
      AX: data.AX,
      AY: data.AY,
      sit: data.sit,
    });
    sleepTime();
  });


  //ç©ºã‹ã‚‰è½ã¡ãŸæ™‚ã®ä½ç½®æƒ…å ±æ˜¯æ­£ç”¨
  socket.on('transformData', data => {
    if (!checkUser()) return;
    user[token].DIR = data.DIR;
    user[token].AX = data.AX;
    user[token].AY = data.AY;
  });

  socket.on("alphaChange", data => {//é€æ˜ã«ã™ã‚‹
    if (!checkUser()) return;
    user[token].avatarAlpha = data.alpha;//ã‚¢ãƒã‚¿ãƒ¼ã®é€æ˜åº¦ã‚’è¨­å®š
    if (user[token].room !== "loginRoom") {
      socket.broadcast.to(user[token].room).emit("alphaChange", {
        token: token,
        alpha: data.alpha,
      });
    }
    sleepTime();
  });



  //ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘ã¨ã£ãŸã‚‰é€ä¿¡
  socket.on("emit_msg", data => {
    if (!checkUser()) return;

    let fontColor = "black";
    if (data.msg == "ã‚¹ã‚·" || data.msg == "ï½½ï½¼" || data.msg == "ã™ã—" || data.msg == "ğŸ£" || data.msg == "å¯¿å¸" || data.msg == "é®¨" || data.msg == "susi") {
      data.msg += "(" + new Date().getHours().toLocaleString() + ":" + new Date().getMinutes().toLocaleString() + ")";
      fontColor = "white";
    }
    if (data.msg == "ã‚‚ã¿ã“ã‚") {
      data.msg += "(ã‚‚ã¿ã˜ã‚†ã‚‹ã•ã‚“ã®ç•¥)";
    }
    if (data.carryOver) {
      user[token].msg = data.msg;
      user[token].carryOver = true;

      //æœ€å¾Œã«ç™ºè¨€ã—ãŸcarryOverãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’userã®æœ€å¾Œã«å…¥ã‚ŒãªãŠã™
      let value = user[token];
      delete user[token];
      user[token] = value;

    } else {//carryOverã˜ã‚ƒãªã„ãªã‚‰ã€userã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æƒ…å ±ã¯æ¶ˆã—ã¨ã
      user[token].msg = "";
      user[token].carryOver = false;
    }


    if (data.msg == "#list" || data.msg == "#ï¾˜ï½½ï¾„" || data.msg == "#ãƒªã‚¹ãƒˆ") {
      let listName = [];
      let listToken = [];
      let n = 0;
      Object.keys(user).forEach(key => {
        if (user[key].room == user[token].room) {
          listName[n] = user[key].userName;
          listToken[n] = key;
          n++;
        }
      });
      io.to(socket.id).emit("list", {
        listName: listName,
        listToken: listToken,
      });


    } else if (data.msg == "#train" || data.msg == "#ï¾„ï¾šï½²ï¾" || data.msg == "#ãƒˆãƒ¬ã‚¤ãƒ³" || data.msg == "#rula" || data.msg == "#ï¾™ï½°ï¾—" || data.msg == "#ãƒ«ãƒ¼ãƒ©" || data.msg == "#é›»è»Š") {

      let trainList = [];
      for (let i = 0; i < roomNameList.length; i++) {
        trainList[i] = roomNameList[i] + ":";
        Object.keys(user).forEach(key => {
          if (user[key].room === roomNameList[i]) {
            if (user[key].video && user[key].audio) {
              trainList[i] += user[key].userName + "ğŸ“ºğŸ”Š "
            } else if (user[key].video) {
              trainList[i] += user[key].userName + "ğŸ“º "
            } else if (user[key].audio) {
              trainList[i] += user[key].userName + "ğŸ”Š "
            } else {
            }
          }
        });
        trainList[i] += rooms[roomNameList[i]].usersToken.size;
      }

      io.to(socket.id).emit("train", {
        roomNameList: roomNameList,
        trainList: trainList,
      });
    } else {
      io.to(user[token].room).emit("emit_msg", {
        userName: user[token].userName,
        msg: data.msg,
        token: token,
        carryOver: data.carryOver,
        fontColor: fontColor,
        soundNum: user[token].soundNum,
      });
    }
    sleepTime();
  });


  //ãŠçµµæãé–¢é€£
  socket.on("oekaki", data => {
    if (!checkUser()) return;
    if (user[token].room !== "loginRoom") {
      const target = data.avatarOekakiToken ? user[data.avatarOekakiToken] : rooms[user[token].room];

      target.drawHistory.push(data.line);

      socket.broadcast.to(user[token].room).emit("oekaki", {
        token: token,
        targetToken: data.avatarOekakiToken,
        line: data.line,
      });
      sleepTime();
    }
  });

  socket.on("oekakiClear", data => {
    if (!checkUser()) return;
    if (user[token].room !== "loginRoom") {
      const target = data.avatarOekakiToken ? user[data.avatarOekakiToken] : rooms[user[token].room];
      target.drawHistory = data.history;
      socket.broadcast.to(user[token].room).emit("oekakiClear", {
        token: token,
        targetToken: data.avatarOekakiToken,
        history: target.drawHistory,
      });
      sleepTime();
    }
  });

  socket.on("undo", data => {//ãŠçµµæãã‚’æˆ»ã™
    if (!checkUser()) return;
    if (user[token].room !== "loginRoom") {
      const target = data.avatarOekakiToken ? user[data.avatarOekakiToken] : rooms[user[token].room];
      target.drawHistory = data.history;
      socket.broadcast.to(user[token].room).emit("undo", {
        token: token,
        targetToken: data.avatarOekakiToken,
        history: target.drawHistory
      });
      sleepTime();
    }
  });




  // ---- é…ä¿¡é–¢é€£ ----
  // When a user send a SDP message
  // broadcast to all users in the room
  socket.on("mediaButton", data => {
    if (!checkUser()) return;
    data.from = token;

    if (user[token].room) {
      socket.broadcast.to(user[token].room).emit("mediaButton", data);
    }
  });


  socket.on("webRtcSignal", data => {
    if (!checkUser()) return;
    data.from = token;

    // get send target
    if (data.sendto) {//sendtoã®é€ã‚Šå…ˆ
      const sendID = socketID[data.sendto];
      socket.to(sendID).emit("webRtcSignal", data);
    }
  });


  socket.on("stream", data => {
    if (!checkUser()) return;
    console.log(data); // ã“ã“ã§undefinedãªã‚‰ã‚µãƒ¼ãƒãƒ¼é€ä¿¡ãƒŸã‚¹
    if (user[token].room !== "loginRoom") {
      let format = "";
      if (data.format === "videoStart") {
        user[token].video = true;
        format = "ãŒå‹•ç”»é…ä¿¡ã‚’å§‹ã‚ã¾ã—ãŸ";
      } else if (data.format === "videoStop") {
        user[token].video = false;
        format = "ãŒå‹•ç”»é…ä¿¡ã‚’çµ‚ã‚ã‚Šã¾ã—ãŸ";
      } else if (data.format === "audioStart") {
        user[token].audio = true;
        format = "ãŒéŸ³å£°é…ä¿¡ã‚’å§‹ã‚ã¾ã—ãŸ";
      } else if (data.format === "audioStop") {
        format = "ãŒéŸ³å£°é…ä¿¡ã‚’çµ‚ã‚ã‚Šã¾ã—ãŸ";
        user[token].audio = false;
      }
      io.to(user[token].room).emit("stream", {
        msg: user[token].userName + format + time(),
        token: token,
      });
      sleepTime();
    }
  });


  // é€€å‡ºæ™‚
  socket.on("disconnect", () => {
    if (!checkUser()) return;
    if (user[token].room !== "loginRoom") {
      rooms[user[token].room].usersToken.delete(token);//éƒ¨å±‹ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤

      io.to(user[token].room).emit("logout", {
        token: token,
        msg: user[token].userName + "ãŒé€€å‡ºã—ã¾ã—ãŸã€‚" + time(),
        room: user[token].room,
        random: volumeRandom(user[token].room, "logout"),
      });
    }

    //ãƒ¡ãƒ¢ãƒªè§£æ”¾
    delete user[token];
    delete socketID[token];

    // close user connection
    console.log((new Date()) + ' Peer disconnected. id=' + socket.id);

    // --- emit ----//ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¨ä½“ã«é€€å‡ºã‚’ä¼ãˆã‚‹ãŸã‚ã®é–¢æ•°ã ãŒã€éƒ¨å±‹ã‚’ã¾ãŸãŒã‚‹é€šçŸ¥ã‚’å®Ÿè£…ã—ã¦ãªã„ã®ã§ã¤ã‹ã£ã¦ãªã„ã€‚
    // emitMessageBroadcast('user disconnected', { id: token});

    //  socket.roomname ã¨ã„ã†å¤‰æ•°ãŒã‚ã‚Œã°ã€ãã®éƒ¨å±‹ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å¼·åˆ¶çš„ã«é€€å‡ºã•ã›ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ‰
    // --- leave room --socket.roomname = roomname;
    // if (socket.roomname) {
    //   socket.leave(socket.roomname);
    // }
  });
});