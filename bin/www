#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('pmachi5:server');
// var http = require('http');

var fs = require('fs');
var https = require('https');
var nmachi_key = '../../../../usr/local/nginx/nmachi20201226.key';
var nmachi_crt = '../../../../usr/local/nginx/nmachi20201226.crt';
var nmachi_chain = '../../../../usr/local/nginx/nmachi20201226.pem';
var options = {
  key: fs.readFileSync(nmachi_key),
  cert: fs.readFileSync(nmachi_crt),
  ca: fs.readFileSync(nmachi_chain)
};


/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */


// var server = http.createServer(app);
var server = https.createServer(options, app);


/**
 * ADDED!! Require Socket.IO
 */
var io = require('socket.io')(server);


/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);



/**
 * ADDED!! Socket.IO Connection.
 */



let user = {};
// user={token:{userName,msg,token,room,AX,AY,DIR}};

let tokenNum = 0;
let tokenID = [];

let users = { "entrance": 0, "utyu": 0 };

var crypto = require("crypto");
const { setInterval } = require('timers');
// var cipers = crypto.getCiphers();
// console.log(cipers);
// var hashes = crypto.getHashes();
// console.log(hashes);

function tripCreate(isTrip) {
  let tripkey = isTrip;
  let salt = tripkey + "H.";//æœªå…¥åŠ›ã€åˆã¯1æ–‡å­—å…¥ã‚Œç”¨ã«H.ã‚’è¿½åŠ ï¼Ÿï¼Ÿ
  salt = salt.substr(1, 2);//2æ–‡å­—ç›®ã¨3æ–‡å­—ç›®ã‚’åˆ‡ã‚Šå‡ºã™
  salt = salt.replace(/[^.-z]/g, ".");
  salt = salt.replace(/:/g, "A");
  salt = salt.replace(/;/g, "B");
  salt = salt.replace(/</g, "C");
  salt = salt.replace(/=/g, "D");
  salt = salt.replace(/>/g, "E");
  salt = salt.replace(/\?/g, "F");
  salt = salt.replace(/@/g, "G");
  salt = salt.replace(/\[/g, "a");
  salt = salt.replace(/\\/g, "b");
  salt = salt.replace(/]/g, "c");
  salt = salt.replace(/\^/g, "d");
  salt = salt.replace(/_/g, "e");
  salt = salt.replace(/`/g, "f");
  let cipher = crypto.createCipher("des", salt);
  cipher.update(tripkey, 'utf-8', 'base64');
  let cipheredText = cipher.final('base64');
  let trip = cipheredText.substr(-10);
  trip = trip.replace(/=/g, "");//ãªã‚“ã‹ã‚ˆãã‚ã‹ã‚‰ã‚“ã‘ã©ã€é«˜ç¢ºç‡ã§å¾Œã‚ã«==ãŒä»˜ãã®ã§æ¶ˆã™
  trip = "â—†" + trip;
  return trip;
}

let msgSE = {};
msgSE.login = {};
msgSE.login.in = new Array(0);
msgSE.login.logout = new Array(0);
msgSE.other = {};
msgSE.other.in = new Array(1);
msgSE.other.out = new Array(3);
msgSE.other.logout = new Array(1);
msgSE.utyu = {};
msgSE.utyu.in = new Array(1);
msgSE.utyu.out = new Array(1);
msgSE.utyu.logout = new Array(1);

let oekaki = {};
oekaki["loginBack"] = {};
oekaki["loginBack"].X = [];
oekaki["loginBack"].Y = [];
oekaki["loginBack"].color = [];
oekaki["loginBack"].alpha = [];
oekaki["entrance"] = {};
oekaki["entrance"].X = [];
oekaki["entrance"].Y = [];
oekaki["entrance"].color = [];
oekaki["entrance"].alpha = [];
oekaki["utyu"] = {};
oekaki["utyu"].X = [];
oekaki["utyu"].Y = [];
oekaki["utyu"].color = [];
oekaki["utyu"].alpha = [];

function volumeRandom(room, move) {
  let random;
  if (room == "entrance") {//â€»éƒ¨å±‹æ•°ãŒå¢—ãˆãŸã‚‰||ã§ç¶™ãè¶³ã™
    random = Math.floor(Math.random() * msgSE.other[move].length);
  } else {
    random = Math.floor(Math.random() * msgSE[room][move].length);
  }
  return random;
}


io.on('connection', function (socket) {
  //ãƒ•ã‚©ãƒ³ãƒˆåˆ‡ã‚Šæ›¿ãˆ
  function saikiMsg() {
    io.to(socket.id).json.emit("emitSaikiMsg", {
      msg: "ãƒ–ãƒ©ã‚¦ã‚¶ã‚’æ›´æ–°ã—ã¦ãã ã•ã„",
    });
  }

  //æ™‚é–“ã§çœ ã£ã¦ã‚‹æ™‚ã«çœ ã‚‰ã›ã‚‹ï¼Ÿâ†è¡¨ç¤ºã‚’èµ·ãã‚‹ã«åˆ‡ã‚Šæ›¿ãˆè§£ã„ãŸã‚‰ã„ã„
  //è‡ªåˆ†ã§çœ ã‚‰ã›ãŸæ™‚ã«æ™‚é–“ã§çœ ã‚‹â†ã“ã®ã¾ã¾

  //è‡ªåˆ†ã§çœ ã£ã¦ã‚‹æ™‚ã¯ãã®ã¾ã¾
  //æ™‚é–“ã§çœ ã£ã¦ã‚‹æ™‚ã¯å‹•ã‹ã—ãŸã‚‰å‹•ã

  socket.on("getMyUser", function () {//soundNumã‚’ä½œã‚‹
    tokenID[socket.id] = "tokenID" + tokenNum;
    user[tokenID[socket.id]] = {
      userName: "åã‚‚ãªãåç„¡ã—",
      token: tokenID[socket.id],
      AX: 457,
      AY: 80,
      DIR: "S",
      msg: "",
      avatar: "gomaneco",
      room: "loginBack",
      selfSleep: false,
      sleepTimeNum: 0,
      countSleep: function () {
        let setTimeoutSleep;
        if (user[socket.id]) {
          user[socket.id].sleepTimeNum++;
          if (user[socket.id].sleepTimeNum == 30 * 60) {
            user[socket.id].sleep = true;
            io.sockets.emit("sleep", {
              token: tokenID[socket.id],
              sleep: user[tokenID[socket.id]].sleep,
            });
          }
          setTimeoutSleep = setTimeout(user[tokenID[socket.id]].countSleep, 1000);
        } else {
          clearTimeout(setTimeoutSleep);
        }
      },
    }
    tokenNum++;
    io.to(socket.id).json.emit("myToken", {
      token: tokenID[socket.id],
    });

    user[tokenID[socket.id]].countSleep();
  });

  socket.on("login_room", function (data) {//ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      if(data.userName.length < 28) {//åå‰ãŒï¼’ï¼˜ä»¥ä¸Šã®ã‚’é˜»æ­¢
      //ãƒˆãƒªãƒƒãƒ—ã‚’ä½œã‚‹
      data.userName = data.userName.replace(/â—†/g, 'â–¡');
      if (data.userName.match(/#/)) {
        let index = data.userName.indexOf("#");
        let tripStr = data.userName.slice(index + 1);
        let tripName = data.userName.slice(0, index);
        data.userName = tripName + tripCreate(tripStr);
      }
      if (data.userName.match(/ï¼ƒ/)) {
        let index = data.userName.indexOf("ï¼ƒ");
        let tripStr = data.userName.slice(index + 1);
        let tripName = data.userName.slice(0, index);
        data.userName = tripName + tripCreate(tripStr);
      }

      user[tokenID[socket.id]].userName = data.userName;//åå‰ã‚’ã‚µãƒã«ä¿å­˜
      user[tokenID[socket.id]].avatar = data.avatar;//ã‚¢ãƒã‚¿ãƒ¼ã‚’è¨­å®š
      user[tokenID[socket.id]].avatarColor = data.avatarColor;//ã‚¢ãƒã‚¿ãƒ¼ã®è‰²ã‚’è¨­å®š
      user[tokenID[socket.id]].avatarAlpha = data.avatarAlpha;//ã‚¢ãƒã‚¿ãƒ¼ã®é€æ˜åº¦ã‚’è¨­å®š

      user[tokenID[socket.id]].room = data.room;//ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã«éƒ¨å±‹ã‚’å…¥ã‚Œã‚‹
      users[data.room]++;//éƒ¨å±‹äººæ•°ã‚’å¤‰æ›´
      socket.join("entrance");

      //soundNumã®æ±ºå®š
      user[tokenID[socket.id]].soundNum = data.userName.length;
      if (data.avatar == "necosuke" || data.avatar == "necosukeMono") {
        user[tokenID[socket.id]].soundNum++;
      }
      user[tokenID[socket.id]].soundNum += data.avatarColor;
      user[tokenID[socket.id]].soundNum = user[tokenID[socket.id]].soundNum % 9;




      time = " -- " + new Date().getHours().toLocaleString() + ":" + new Date().getMinutes().toLocaleString() + "--";//å…¥å®¤æ™‚ã®æ™‚é–“ã‚’è¨­å®š


      socket.broadcast.emit("loadAvatar", {//å…¨ä½“ã«æ–°è¦å…¥å ´è€…ã‚’èª­ã¿ã“ã¾ã™ã€å¾Œã€…å…¨ä½“äººæ•°ã‚‚ã“ã“ã§ç®¡ç†ã—ã¦ã„ã„ã‹ãª
        token: tokenID[socket.id],
        avatar: data.avatar,
        userName: user[tokenID[socket.id]].userName,
        avatarColor: user[tokenID[socket.id]].avatarColor,
        avatarAlpha: user[tokenID[socket.id]].avatarAlpha,
      });

      io.to(socket.id).json.emit("roomInSelf", {
        beforeRoom: "login",
        user: user,
        room: "entrance",
        users: users[data.room],
        msg: user[tokenID[socket.id]].userName + "ãŒ" + data.room + "ã«å…¥å®¤ã—ã¾ã—ãŸã€‚" + time,
        roomSE: "login",
        random: volumeRandom("login", "in"),
        oekakiX: oekaki[user[tokenID[socket.id]].room].X,
        oekakiY: oekaki[user[tokenID[socket.id]].room].Y,
        oekakiColor: oekaki[user[tokenID[socket.id]].room].color,
        oekakiAlpha: oekaki[user[tokenID[socket.id]].room].alpha,
      });

      socket.broadcast.to(data.room).emit("roomInNonSelf", {
        token: tokenID[socket.id],
        room: "entrance",
        msg: user[tokenID[socket.id]].userName + "ãŒ" + data.room + "ã«å…¥å®¤ã—ã¾ã—ãŸã€‚" + time,
        users: users[data.room],//äººæ•°
        AX: 457,
        AY: 80,
        DIR: "S",
        roomSE: "login",
        random: volumeRandom("login", "in"),
        sleep: user[tokenID[socket.id]].sleep,
        userName: user[tokenID[socket.id]].userName,
      });

      if (user[tokenID[socket.id]].sleepTimeNum >= 30 * 60 && user[tokenID[socket.id]].selfSleep == false) {
        user[tokenID[socket.id]].sleep = false;
        io.sockets.emit("sleep", {
          token: tokenID[socket.id],
          sleep: user[tokenID[socket.id]].sleep,
        });
      }
      user[tokenID[socket.id]].sleepTimeNum = 0;
    }
    } else {
      saikiMsg();//å†èµ·å‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
    }
  });

  socket.on("roomIn", function (data) {
    if (user[tokenID[socket.id]]) {////ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      time = " -- " + new Date().getHours().toLocaleString() + ":" + new Date().getMinutes().toLocaleString() + "--";//å…¥å®¤æ™‚ã®æ™‚é–“
      let before = data.beforeRoom;
      let after = data.afterRoom;
      socket.leave(before);
      socket.join(after);
      users[before]--//å…¥å®¤å‰ã®éƒ¨å±‹äººæ•°ã‚’æ¸›ã‚‰ã™
      users[after]++;//å…¥å®¤å¾Œã®éƒ¨å±‹äººæ•°ã‚’å¢—ã‚„ã™

      user[tokenID[socket.id]].room = data.afterRoom;
      user[tokenID[socket.id]].AX = data.AX;
      user[tokenID[socket.id]].AY = data.AY;
      user[tokenID[socket.id]].DIR = data.DIR;
      user[tokenID[socket.id]].msg = "";

      io.to(socket.id).json.emit("roomInSelf", {
        user: user,
        room: data.afterRoom,
        msg: user[tokenID[socket.id]].userName + "ãŒ" + data.beforeRoom + "ã‹ã‚‰ç§»å‹•ã—ã¦ãã¾ã—ãŸã€‚" + time,
        users: users[after],
        roomSE: data.afterRoom,
        random: volumeRandom(data.afterRoom, "in"),
        oekakiX: oekaki[user[tokenID[socket.id]].room].X,
        oekakiY: oekaki[user[tokenID[socket.id]].room].Y,
        oekakiColor: oekaki[user[tokenID[socket.id]].room].color,
        oekakiAlpha: oekaki[user[tokenID[socket.id]].room].alpha,
        sleep: user[tokenID[socket.id]].sleep,
      });

      socket.broadcast.to(after).emit("roomInNonSelf", {//è‡ªåˆ†ä»¥å¤–ãŒéƒ¨å±‹ã«å…¥ã£ãŸå ´åˆ
        token: tokenID[socket.id],
        room: data.afterRoom,
        msg: user[tokenID[socket.id]].userName + "ãŒ" + data.beforeRoom + "ã‹ã‚‰ç§»å‹•ã—ã¦ãã¾ã—ãŸã€‚" + time,
        users: users[data.afterRoom],//äººæ•°
        AX: data.AX,
        AY: data.AY,
        DIR: data.DIR,
        roomSE: data.afterRoom,
        random: volumeRandom(data.afterRoom, "in"),
        sleep: user[tokenID[socket.id]].sleep,

      });
      socket.broadcast.to(before).emit("roomOutNonSelf", {//è‡ªåˆ†ä»¥å¤–ãŒéƒ¨å±‹ã‚’å‡ºãŸå ´åˆ
        token: tokenID[socket.id],
        room: data.afterRoom,
        random: volumeRandom(data.beforeRoom, "out"),
      });
    } else {
      saikiMsg();
    }
  });



  //ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã£ã¦é€ä¿¡
  socket.on("emit_msg", function (data) {
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
        let fontColor = "black";
        if (data.msg == "ã‚¹ã‚·" || data.msg == "ï½½ï½¼" || data.msg == "ã™ã—" || data.msg == "ğŸ£" || data.msg == "å¯¿å¸" || data.msg == "é®¨" || data.msg == "susi") {
          data.msg += "(" + new Date().getHours().toLocaleString() + ":" + new Date().getMinutes().toLocaleString() + ")";
          fontColor = "white";
        }
      
        if (data.kanban) {
          user[tokenID[socket.id]].msg = data.msg;
        
          //æœ€å¾Œã«ç™ºè¨€ã—ãŸkanbanã‚’userã®æœ€å¾Œã«å…¥ã‚ŒãªãŠã™
          let value = user[tokenID[socket.id]];
          delete user[tokenID[socket.id]];
          user[tokenID[socket.id]] = value;
        } else {//kanbanã˜ã‚ƒãªã„ãªã‚‰ã€userã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æƒ…å ±ã¯æ¶ˆã—ã¨ã
          user[tokenID[socket.id]].msg = "";
        }

 
      
        io.to(user[tokenID[socket.id]].room).emit("emit_msg", {
          userName: user[tokenID[socket.id]].userName,
          msg: data.msg,
          token: tokenID[socket.id],
          avaMsg: data.msg,
          kanban: data.kanban,
          fontColor: fontColor,
          soundNum: user[tokenID[socket.id]].soundNum,
        });
        if (user[tokenID[socket.id]].userName.sleepTimeNum >= 30 * 60 && user[tokenID[socket.id]].selfSleep == false) {
          user[tokenID[socket.id]].sleep = false;
          io.sockets.emit("sleep", {
            token: tokenID[socket.id],
            sleep: user[tokenID[socket.id]].sleep,
          });
        }
        user[tokenID[socket.id]].sleepTimeNum = 0;
    } else {
      saikiMsg();
    }
  });

  //ã‚¢ãƒœãƒ³ã®æ™‚
  socket.on("abonSetting", function (data) {
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      let abonMsg;
      let abonAvaMsg;
      if (user[data.token] == null) {
        abonMsg = "ãã®ä½æ°‘ã¯é€€å‡ºæ¸ˆã¿ã§ã™";
        io.to(socket.id).json.emit("abonSetting", {
          msg: abonMsg,
          token: data.token,
          avaMsg: abonAvaMsg,
        });
      } else if (data.setAbon) {
        abonMsg = user[data.token].userName + "ã‚’ã‚¢ãƒœãƒ³ã—ã¾ã—ãŸã€‚";
        abonAvaMsg = "ã‚¢ãƒœãƒ³";//å¹ãå‡ºã—ã‚’ã‚¢ãƒœãƒ³ã«ã™ã‚‹ã€‚
        io.to(socket.id).json.emit("abonSetting", {
          msg: abonMsg,
          token: data.token,
          avaMsg: abonAvaMsg,
          AX: user[data.token].AX,
          AY: user[data.token].AY,
          DIR: user[data.token].DIR,
          room: user[data.token].room,
        });
      } else {
        abonMsg = user[data.token].userName + "ã®ã‚ã¼ã‚“ã‚’ã‚„ã‚ã¾ã—ãŸ";
        abonAvaMsg = "";
        io.to(socket.id).json.emit("abonSetting", {
          msg: abonMsg,
          token: data.token,
          avaMsg: abonAvaMsg,
          AX: user[data.token].AX,
          AY: user[data.token].AY,
          DIR: user[data.token].DIR,
          room: user[data.token].room,
        });
      }
      if (user[tokenID[socket.id]].sleepTimeNum >= 30 * 60 && user[tokenID[socket.id]].selfSleep == false) {
        user[tokenID[socket.id]].sleep = false;
        io.sockets.emit("sleep", {
          token: tokenID[socket.id],
          sleep: user[tokenID[socket.id]].sleep,
        });
      }
      user[tokenID[socket.id]].sleepTimeNum = 0;
    } else {
      saikiMsg();//å†èµ·å‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
    }
  });



  //ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
  socket.on('tapMap', function (data) {
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      user[tokenID[socket.id]].DIR = data.DIR;
      user[tokenID[socket.id]].AX = data.AX;
      user[tokenID[socket.id]].AY = data.AY;

      socket.broadcast.to(user[tokenID[socket.id]].room).emit("tapMap", {
        DIR: data.DIR,
        token: tokenID[socket.id],
        AX: data.AX,
        AY: data.AY,
      });
      if (user[tokenID[socket.id]].sleepTimeNum >= 30 * 60 && user[tokenID[socket.id]].selfSleep == false) {
        user[tokenID[socket.id]].sleep = false;
        io.sockets.emit("sleep", {
          token: tokenID[socket.id],
          sleep: user[tokenID[socket.id]].sleep,
        });
      }
      user[tokenID[socket.id]].sleepTimeNum = 0;
    } else {
      saikiMsg();//å†èµ·å‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
    }
  });

  socket.on("alphaChange", function (data) {//é€æ˜ã«ã™ã‚‹
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      user[tokenID[socket.id]].avatarAlpha = data.alpha;//ã‚¢ãƒã‚¿ãƒ¼ã®é€æ˜åº¦ã‚’è¨­å®š
      if (user[tokenID[socket.id]].room !== "loginBack") {
        socket.broadcast.emit("alphaChange", {
          token: tokenID[socket.id],
          alpha: data.alpha,
        });
      }
      if (user[tokenID[socket.id]].sleepTimeNum >= 30 * 60 && user[tokenID[socket.id]].selfSleep == false) {
        user[tokenID[socket.id]].sleep = false;
        io.sockets.emit("sleep", {
          token: tokenID[socket.id],
          sleep: user[tokenID[socket.id]].sleep,
        });
      }
      user[tokenID[socket.id]].sleepTimeNum = 0;
    } else {
      saikiMsg();//å†èµ·å‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
    }
  });

  socket.on("sleep", function () {//sleepã«é–¢ã—ã¦,å—ã‘å–ã£ãŸã‚‰è‡ªåˆ†ä»¥å¤–ã®éƒ¨å±‹ã®äººã«ã‚¹ãƒªãƒ¼ãƒ—æƒ…å ±ã‚’é€ã‚‹
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      if (user[tokenID[socket.id]].sleep) {//å¯ã¦ãŸæ™‚
        user[tokenID[socket.id]].sleep = false;
        user[tokenID[socket.id]].selfSleep = false;
        user[tokenID[socket.id]].DIR = "S";
      } else {//èµ·ãã¦ãŸæ™‚
        user[tokenID[socket.id]].sleep = true;
        user[tokenID[socket.id]].selfSleep = true;
      }
      socket.broadcast.to(user[tokenID[socket.id]].room).emit("sleep", {
        token: tokenID[socket.id],
        sleep: user[tokenID[socket.id]].sleep,
      });
      user[tokenID[socket.id]].sleepTimeNum = 0;
    } else {
      saikiMsg();//å†èµ·å‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
    }
  });


  socket.on("oekaki", function (data) {
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      oekaki[user[tokenID[socket.id]].room].X.push(data.oekakiX);
      oekaki[user[tokenID[socket.id]].room].Y.push(data.oekakiY);
      oekaki[user[tokenID[socket.id]].room].color.push(data.oekakiColor);
      oekaki[user[tokenID[socket.id]].room].alpha.push(data.oekakiAlpha);
      io.to(user[tokenID[socket.id]].room).emit("oekaki", {
        token: tokenID[socket.id],
        oekakiX: data.oekakiX,
        oekakiY: data.oekakiY,
        oekakiColor: data.oekakiColor,
        oekakiAlpha: data.oekakiAlpha,
      });
      if (user[tokenID[socket.id]].sleepTimeNum >= 30 * 60 && user[tokenID[socket.id]].selfSleep == false) {
        user[tokenID[socket.id]].sleep = false;
        io.sockets.emit("sleep", {
          token: tokenID[socket.id],
          sleep: user[tokenID[socket.id]].sleep,
        });
      }
      user[tokenID[socket.id]].sleepTimeNum = 0;
    } else {
      saikiMsg();//å†èµ·å‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
    }
  });
  socket.on("clearCanvas", function (data) {
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      oekaki[user[tokenID[socket.id]].room].X = [];
      oekaki[user[tokenID[socket.id]].room].Y = [];
      oekaki[user[tokenID[socket.id]].room].color = [];
      oekaki[user[tokenID[socket.id]].room].alpha = [];
      io.to(user[tokenID[socket.id]].room).emit("clearCanvas", {
        token: tokenID[socket.id],
      });
      if (user[tokenID[socket.id]].sleepTimeNum >= 30 * 60 && user[tokenID[socket.id]].selfSleep == false) {
        user[tokenID[socket.id]].sleep = false;
        io.sockets.emit("sleep", {
          token: tokenID[socket.id],
          sleep: user[tokenID[socket.id]].sleep,
        });
      }
      user[tokenID[socket.id]].sleepTimeNum = 0;
    } else {
      saikiMsg();//å†èµ·å‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
    }
  });

  // ---- multi room ----


  // function emitMessageBroadcast(type, message) {
  //   // ----- multi room ----
  //   if (user[tokenID[socket.id]].room) {
  //     //console.log('===== message broadcast to room -->' + roomname);
  //     socket.broadcast.to(user[tokenID[socket.id]].room).emit(type, message);
  //   }
  //   // else {//éƒ¨å±‹åã‚’å–å¾—ã§ããªã‹ã£ãŸã‚‰
  //   //   console.log('===== message broadcast all');
  //   //   socket.broadcast.emit(type, message);
  //   // }
  // }

  // When a user send a SDP message
  // broadcast to all users in the room
  socket.on('message', function (message) {
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      message.from = tokenID[socket.id];


      // get send target
      if (message.sendto) {//sendtoã®é€ã‚Šå…ˆ
        let sendID;
        Object.keys(tokenID).forEach(function (key) {
          if (tokenID[key] === message.sendto) {
            sendID = key;
          }
        });
        socket.to(sendID).emit('message', message);
        return;
      }

      // broadcast in room
      // emitMessageBroadcast('message', message);//è‡ªåˆ†ä»¥å¤–ã«

      if (user[tokenID[socket.id]].room) {
        //console.log('===== message broadcast to room -->' + roomname);
        socket.broadcast.to(user[tokenID[socket.id]].room).emit('message', message);
      }

    }    
  });


  // é€€å‡ºæ™‚
  socket.on("disconnect", function () {
    if (user[tokenID[socket.id]]) {//ã‚µãƒå†èµ·å‹•å‰ã«é–‹ã‹ã‚Œã¦ã„ãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®å…¥åŠ›ã‚’é˜»æ­¢ã™ã‚‹ã€‚
      if (user[tokenID[socket.id]].room !== "loginBack") {
        users[user[tokenID[socket.id]].room]--;

        time = " -- " + new Date().getHours().toLocaleString() + ":" + new Date().getMinutes().toLocaleString() + "--";

        io.to(user[tokenID[socket.id]].room).emit("logout", {
          token: tokenID[socket.id],
          msg: user[tokenID[socket.id]].userName + "ãŒé€€å‡ºã—ã¾ã—ãŸã€‚" + time,
          room: user[tokenID[socket.id]].room,
          users: users[user[tokenID[socket.id]].room],
          random: volumeRandom(user[tokenID[socket.id]].room, "logout"),
        });
      }
    }
    delete user[tokenID[socket.id]];


    // close user connection
    console.log((new Date()) + ' Peer disconnected. id=' + socket.id);

    // --- emit ----
    // emitMessageBroadcast('user disconnected', { id: tokenID[socket.id]});

    // --- leave room --socket.roomname = roomname;
    // if (socket.roomname) {
    //   socket.leave(socket.roomname);
    // }
  });
});


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
